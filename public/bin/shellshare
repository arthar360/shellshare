#!/usr/bin/env python
import tempfile
import string
import random
import thread
import time
import base64
import sys
import urllib
import urllib2
import os
import subprocess
import platform
import json
import httplib
import socket
import errno


def id_generator(size=18, chars=string.ascii_letters + string.digits):
    return ''.join(random.choice(chars) for x in range(size))


def terminal_size():
    cols = subprocess.Popen('tput cols', shell=True, stdout=subprocess.PIPE)
    rows = subprocess.Popen('tput lines', shell=True, stdout=subprocess.PIPE)
    cols = int(cols.stdout.read().strip())
    rows = int(rows.stdout.read().strip())
    return {'cols': cols, 'rows': rows}


def post(conn, url, data, channel, authorization):
    headers = {'Content-type': 'application/x-www-form-urlencoded',
               'Authorization': authorization}
    size = json.dumps(terminal_size())
    data = urllib.urlencode({'message': data, 'size': size})
    try:
        conn.request('POST', '/%s' % channel, data, headers)
        res = conn.getresponse()
        res.read()

        if res.status == 401:
            print 'You\'re unauthorized to share on http://%s/%s.' % \
                  (url, channel)
            thread.exit()
        elif res.status != 200:
            print 'Received HTTP Error (Status Code %d).' % res.status
            thread.exit()
    except httplib.BadStatusLine as e:
        print 'Can\'t contact the server. Please try again later.'
        thread.exit()
    except socket.error as e:
        if e.errno != errno.ECONNREFUSED:
            raise e
        print 'Can\'t contact the server. Please try again later.'
        thread.exit()


def stream_file(path, url, channel, authorization):
    conn = httplib.HTTPConnection(url)
    f = open(path, 'rb')
    while True:
        time.sleep(1)
        # osx wants this because EOF is cached
        f.seek(0, os.SEEK_CUR)
        data = f.read()
        if not (data == ""):
            urlencoded = urllib2.quote(data)
            encoded_str = base64.b64encode(urlencoded)
            post(conn, url, encoded_str, channel, authorization)


tmp = tempfile.NamedTemporaryFile()
channel = sys.argv[1] if len(sys.argv) >= 2 else id_generator()
channel = 'r/%s' % channel
authorization = sys.argv[2] if len(sys.argv) >= 3 else id_generator()
url = 'www.shellshare.net'

if platform.system() == 'Darwin':
    shell_args = '-qt 0'
else:
    shell_args = '-qf'

print 'Sharing session in http://%s/%s...' % (url, channel)
thread.start_new_thread(stream_file, (tmp.name, url, channel, authorization))
subprocess.call('script %s %s' % (shell_args, tmp.name), shell=True)
print 'End of transmission.'
